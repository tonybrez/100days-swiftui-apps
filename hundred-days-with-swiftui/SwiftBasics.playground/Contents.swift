import Foundation

// MARK:  --- DAY 1 ---
/*
 VARIABLES are an instruction to hold data.
 The 'var' keyword tells us the value can be changed.
 The 'let' keyword is a constant variable that can't be changed.
 It is good practice to always use 'let' to create variables and then change it to 'var' when change is necessary.
 The convention for naming variables is camelCase.
*/
var greeting = "Hello, world!"
var name = "Tony"
name = "Samantha"
name = "Ted"

let character = "Daphne"
/// character = "Eloise" --> This will throw an error. 'let' are constants, therefore it can't be changed

/*
 STRING is text assign to a variable.
 It can either be single line, or multi-line. Multi-line strings are useful for readability, and for when you need text while linebreaks to be specific, as most implementations will only try to text-wrap it or not.
 Strings also have useful functionality attached to them.
 */
let actor = "Denzel Washington"
let movie = """
A day in
the \"life\" of an
Apple engineer
"""
print(actor.uppercased())
print(movie.lowercased())
print(movie.count)
print(movie.hasPrefix("A day"))
print(movie.hasSuffix(".jpg"))

/*
 INTEGERS are variables that store whole numbers.
 They can be either positive or negative, as small or big.
 You can also create integers from other integers using arithmetic operators,
*/
let score = 10
let reallyBig = 1_00__00___00____00

let lowerScore = score - 2
let higherScore = score + 10
let doubledScore = score * 2
let squaredScore = score * score
let halvedScore = score / 2

var counter = 10
counter = counter + 5
counter += 5
counter *= 2
counter -= 10
counter /= 2

let number = 120
print(number.isMultiple(of: 3))

/*
 DOUBLES are variables that store decimals.
 Decimals are called floating-point numbers. The name comes from the surprisingly complex way the numbers are stored by your computer.
 The same arithmethic operators that are applied to Int can be applied in Double as well
 CGFloat can be ignored; it's only used by older APIs. Use Double whenever possible instead of CGFloat.
 */
let doubleNumber = 0.1 + 0.2
print(doubleNumber) /// This will print 0.30000000000000004 because of the complexity of storing decimal numbers in computers. That said, these margins of error are mostly irrelevant.

let a = 1
let b = 2.0
/// let c = a + b // This will throw error because Int and Double can't be mixed. Also, even though both are whole numbers in practice (1 is 1, and 2.0 is 2), variables can be changed (2.0 can later be 2.3 for example) so Swift is playing it safe.
let cDouble = Double(a) + b
let cInt = a + Int(b)

var rating = 5.0
rating *= 2

// NOTE: Swift is a type-safe language. Variables can't have their typing changed once declared, either explicitly or implicitly.


// MARK:  --- DAY 2 ---
/*
 BOOLEAN are variables that can only hold two possible values, either true or false.
 Booleans don't have arithmethic operators but they have the "not" operator, using "!".
 Booleans can also be the result of any functionality that ultimately results either in true or false, including boolean's toggle() functionality.
 */
let goodDogs = true
let gameOver = false
let isMultiple = 120.isMultiple(of: 3)

var isAuthenticated = false
isAuthenticated = !isAuthenticated
print(isAuthenticated)
isAuthenticated = !isAuthenticated
print(isAuthenticated)
isAuthenticated.toggle()
print(isAuthenticated)

/*
 STRING INTERPOLATION is a way of combining Strings together.
 To interpolate, you can use '+' between Strings, or \(variable) inside the String assignment.
 Only Strings themselves can be interpolated. Other types of data would need to be casted to String or represented as a String.
 String interpolation is incredibly useful in real apps because it allows presenting dynamic data on text, either generated by the code or fetched from other sources like databases or services.
 */
let firstPart = "Hello, "
let secondPart = "world!"
let greetingInterpolated = firstPart + secondPart

let people = "Haters"
let action = "hate"
let lyric = people + " gonna " + action
print(lyric)

let luggageCode = "1" + "2" + "3" + "4" + "5"
print(luggageCode) /// This will result in "12345" and not "15" because these are interpolated Strings, not adding Ints.

let taylorName = "Taylor"
let taylorAge = 26
let taylorMessage = "Hello, my name is \(taylorName) and I'm \(taylorAge) years old."
print(taylorMessage)

let apolloNumber = 11
/// let missionMessage1 = "Apollo " + apolloNumber + " landed on the moon." // This will fail because you can't directly interpolate a non-String into a String
let missionMessage2 = "Apollo " + String(apolloNumber) + " landed on the moon." /// apolloNumber is being casted to a String
let missionMessage3 = "Apollo \(apolloNumber) landed on the moon." /// apolloNumber is being casted to a String
print("5 x 5 is \(5 * 5)") /// Arithmethic operations can be casted into a String during interpolation


// MARK:  --- DAY 3 ---
/*
 ARRAYS are a collection variable that group many values in one place.
 Arrays are strongly-typed. It can't hold values of a different data type of what was defined as.
 Array values can be read back using arrayName[i], with 'i' being the index value of where the value is placed in the array, with '0' being the first value.
 Arrays have many functionalities, like .append() to add an item, .remove() to remove an item, .count to get the total amount of items in the array, and many others.
 */

var beatles = ["John", "Paul", "George", "Ringo"]
let intsInArray = [4, 8, 15, 16, 23, 42]
var doublesInArray = [25.3, 28.2, 26.4]

print(beatles[0])
print(intsInArray[1])
print(doublesInArray[2])

beatles.append("Allen")
beatles.append("Adrian")
beatles.append("Adrian")
beatles.append("Novall")
beatles.append("Vivian")
/// doublesInArray.append("Chris") // This will throw an error. You can't append an item with a different data type than what the array is defined as.

let firstBeatle = beatles[0]
let firstNumber = intsInArray[0]
/// let notAllowed = firstBeatle + firstNumber // This will throw and error. Trying to add or concatenate two differet data types.

var testScores = Array<Int>()
testScores.append(100)
testScores.append(80)
testScores.append(85)
print(testScores[1])

var albums1 = Array<String>()
albums1.append("Folklore")
albums1.append("Fearless")
albums1.append("Red")
var albums2 = [String]()
albums2.append("Folklore")
albums2.append("Fearless")
albums2.append("Red")
albums2.remove(at: 0)
print(albums1.count)
print(albums2.count)

let bondMovies = ["Casino Royale", "Spectre", "No Time To Die"]
print(bondMovies.contains("Frozen"))

let cities = ["London", "Tokyo", "Rome", "Budapest"]
print(cities.sorted())

let presidents = ["Bush", "Obama", "Trump", "Biden"]
let reversedPresidents = presidents.reversed()
print(reversedPresidents)

/*
 DICTIONARIES are a collection variable that group many values in one place, but unlike arrays, they are not references by indeces, but by keys.
 Dictionaries are strongly-typed on both the key and value, and has many features like .removeAll() and .count.
 Dictionaries are useful because they don't depend on the adding/removal for the order of indeces, and create a better relationship between the reference and the value it has.
 Unlike arrays that crash the runtine when trying to access an index that doesn't exist, accessing a key that doesn't exist returns nil, or a predefined default value.
 */
let employee = [
    "name": "Taylor Swift",
    "job": "Singer",
    "location": "Nashville"
]
print(employee["name"] ?? "")
print(employee["job"] ?? "")
print(employee["location"] ?? "")
print(employee["password"] ?? "") /// Unlike arrays, dictionaries will not make runtime crash when a value is not found.
print(employee["status"] ?? "")
print(employee["manager"] ?? "")

let hasGraduated = [ /// Key: Value can be of different data types, like booleans for example.
    "Eric": false,
    "Maeve": true,
    "Otis": false,
]

let olympics = [
    2012: "London",
    2016: "Rio de Janeiro",
    2021: "Tokyo"
]
print(olympics[2008, default: "Unknown"]) /// You can provide default values for when a key doesn't exist.
print(olympics[2008] as Any)

var heights = [String: Int]() /// You can initialize an empty array with an explicit typing that you want to store.
heights["Yao Ming"] = 229
heights["Shaquille O'Neal"] = 216
heights["LeBron James"] = 206

var archEnemies = [String: String]()
archEnemies["Batman"] = "The Joker"
archEnemies["Superman"] = "Lex Luthor"
archEnemies["Batman"] = "Penguin" /// You can rewrite the value of a specific key.

/*
 SETS are a collection variable similar to arrays, with a few differences.
 1. Sets are specifically created by enclosing an array [Any} inside Set().
 2. Sets don't guarantee any order or indeces.
 3. Since Sets don't guarantee orders and don't have indeces, reading sets and its values is much faster in performance.
 Sets have functionalities similar to array, like insert() (similar to append, but named differently because appending means adding at the end, but sets don't guarantee any order), contains(), sorted(), .count, etc.
 */
let actors = Set(["Denzel Washington", "Tom Cruise", "Nicolas Cage", "Samuel L Jackson"])
print(actors)

var actors2 = Set<String>()
actors2.insert("Denzel Washington")
actors2.insert("Tom Cruise")
actors2.insert("Nicolas Cage")
actors2.insert("Samuel L Jackson")

/*
 ENUMS is for enumerations. It is a grouping of named values that hold a relation with each other.
 It is more efficient and safer to use enums when needed.
 */
enum Weekday {
    /// enum declaration using case for each value
    case monday
    case tuesday
    case wednesday
    case thursday
    case friday
}
var day = Weekday.monday
day = Weekday.tuesday
day = Weekday.friday

enum Dia {
    /// shortdanded enum declaration using one instance of the case keyword
    case lunes, martes, miercoles, jueves, viernes
}
var dia = Dia.lunes
day = .tuesday /// The enum name can be skipped once the variable has been already strongly defined.
day = .friday


// MARK:  --- DAY 4 ---
/*
 TYPE ANNOTATIONS declares a typing for a variable and it lets us be specific about what data type we want.
 When a type annotation is not given, the type is inferred by the value it is given. Swift can’t figure out what type should be used abd sinetunes you don't want to assign a value just yet.
 Type annotation are useful for readability and to avoid confusion, like declaring a whole number that we may want to to really be a Double.
 Custom data like classes, enums and typealiases, between others, can be used as type annotations.
 */
let surname = "Lasso" /// These variables don't have type annotations, so their data types are inferred/implicit.
var scoring = 0

let surname2: String = "Lasso" /// These variables have type annotations, so their data types are explicit.
var scoring2: Int = 0

var scoring3: Double = 3  /// Even though 3 is a whole number, a Double type annotation is defined, so technically this will be stored as 3.0.

let playerName: String = "Roy" /// String explicit typing
var luckyNumber: Int = 13 /// Int explicit typing
let pi: Double = 3.141 /// Double explicit typing
var isAuthenticatedPlayer: Bool = true /// Bool explicit typing
var albums: [String] = ["Red", "Fearless"] /// Array of Strings explicit typing
var user: [String: String] = ["id": "@twostraws"] /// Dictionary of String : String explicit typing
var books: Set<String> = Set(["The Bluest Eye", "Foundation", "Girl, Woman, Other"]) /// Set of Strings explicit typing
var teams: [String] = [String]() /// One way of Empty Array of Strings explicit typing
var countries: [String] = [] /// Another way of Empty Array of Strings explicit typing
var clues = [String]() /// Empty Array of Strings explicit typing but not using a type annotation
enum UIStyle {
    case light, dark, system
}
var style = UIStyle.light /// UIStyle enum type explicit typing

// let score: Int = "Zero" /// This will throw an error. Swift will not how to convert this.

// NOTE: Creating empty collections with type annotations is useful for when we don't know all the daya upfront.


// MARK:  --- DAY 5 ---
/*
 CONDITIONS are used to make choices by comparing values.
 'if' statement lets us check if a condition is true to let us run some code.
 'else if' statme lets us check if a condition is true after 'if' has been checked as false and prior 'else if' have been also checked as false, to let us run some code.
 'else' statement lets us run some code after all prior 'if' and 'else if' statements have been checked false.
 */

let someCondition = true
if someCondition {
    print("Do something")
    print("Do something else")
    print("Do a third thing")
}

let speed = 88
let percentage = 85
let myAge = 18

if speed >= 88 {
    print("Where we're going we don't need roads.")
}

if percentage < 85 {
    print("Sorry, you failed the test.")
}

if myAge >= 18 {
    print("You're eligible to vote")
}

let ourName = "Dave Lister"
let friendName = "Arnold Rimmer"

if ourName < friendName {
    print("It's \(ourName) vs \(friendName)")
}

if ourName > friendName {
    print("It's \(friendName) vs \(ourName)")
}

// Make an array of 3 numbers
var numbers = [1, 2, 3]

// Add a 4th
numbers.append(4)

// If we have over 3 items
if numbers.count > 3 {
    // Remove the oldest number
    numbers.remove(at: 0)
}

let country = "Canada"

if country == "Australia" {
    print("G'day!")
}

let taylorSwiftName = "Taylor Swift"

if taylorSwiftName != "Anonymous" {
    print("Welcome, \(taylorSwiftName)")
}

// Create the username variable
var username = "taylorswift13"

// If `username` contains an empty string
if username == "" {
    // Make it equal to "Anonymous"
    username = "Anonymous"
}

// Now print a welcome message
print("Welcome, \(username)!")

if username.count == 0 {
    username = "Anonymous"
}

if username.isEmpty == true {
    username = "Anonymous"
}

if username.isEmpty {
    username = "Anonymous"
}

// Display the result
print(numbers)

let firstName = "Paul"
let secondName = "Sophie"

let firstAge = 40
let secondAge = 10

print(firstName == secondName)
print(firstName != secondName)
print(firstName < secondName)
print(firstName >= secondName)

print(firstAge == secondAge)
print(firstAge != secondAge)
print(firstAge < secondAge)
print(firstAge >= secondAge)

enum Sizes: Comparable {
    case small
    case medium
    case large
}

let first = Sizes.small
let second = Sizes.large
print(first < second)

// Checking multiple conditions
if myAge >= 18 {
    print("You can vote in the next election.")
}
if myAge < 18 {
    print("Sorry, you're too young to vote.")
}

if myAge >= 18 {
    print("You can vote in the next election.")
} else {
    print("Sorry, you're too young to vote.")
}

let aCondition = false
let bCondition = true
if aCondition {
    print("Code to run if a is true")
} else if bCondition {
    print("Code to run if a is false but b is true")
} else {
    print("Code to run if both a and b are false")
}

let tempCondition = 25
if tempCondition > 20 {
    if tempCondition < 30 {
        print("It's a nice day.")
    }
}
if tempCondition > 20 && tempCondition < 30 {
    print("It's a nice day.")
}

let userAge = 14
let hasParentalConsent = true
if userAge >= 18 || hasParentalConsent == true {
    print("You can buy the game")
}
if userAge >= 18 || hasParentalConsent {
    print("You can buy the game")
}

/*
 I’d like to pick out a few parts of that code:

 When we set the value for transport we need to be explicit that we’re referring to TransportOption.airplane. We can’t just write .airplane because Swift doesn’t understand we mean the TransportOption enum.
 Once that has happened, we don’t need to write TransportOption any more because Swift knows transport must be some kind of TransportOption. So, we can check whether it’s equal to .airplane rather than TransportOption.airplane.
 The code using || to check whether transport is equal to .airplane or equal to .helicopter, and if either of them are true then the condition is true, and “Let’s fly!” is printed.
 If the first condition fails – if the transport mode isn’t .airplane or .helicopter – then the second condition is run: is the transport mode .bicycle? If so, “I hope there’s a bike path…” is printed.
 If we aren’t going by bicycle either, then we check whether we’re going by car. If we are, “Time to get stuck in traffic.” is printed.
 Finally, if all the previous conditions fail then the else block is run, and it means we’re going by scooter.
 */
enum TransportOption {
    case airplane, helicopter, bicycle, car, scooter
}
let transport = TransportOption.airplane
if transport == .airplane || transport == .helicopter {
    print("Let's fly!")
} else if transport == .bicycle {
    print("I hope there's a bike path…")
} else if transport == .car {
    print("Time to get stuck in traffic.")
} else {
    print("I'm going to hire a scooter now!")
}

// if vs else if
let ifElseScore = 9001
if score > 9000 {
    print("It's over 9000!")
}
if score <= 9000 {
    print("It's not over 9000!")
}

if score > 9000 {
    print("It's over 9000!")
} else {
    print("It's not over 9000!")
}

if score > 9000 {
    print("It's over 9000!")
} else {
    if score == 9000 {
        print("It's exactly 9000!")
    } else {
        print("It's not over 9000!")
    }
}

if score > 9000 {
    print("It's over 9000!")
} else if score == 9000 {
    print("It's exactly 9000!")
} else {
    print("It's not over 9000!")
}

// Check multiple conditions
let isOwnerCondition = true
let isAdminCondition = false
let isEditingEnabledCondition = true
if isOwnerCondition == true || isAdminCondition == true {
    print("You can delete this post")
}
if isOwnerCondition == true && isEditingEnabledCondition || isAdminCondition == true {
    print("You can delete this post")
}
if (isOwnerCondition == true && isEditingEnabledCondition) || isAdminCondition == true {
    print("You can delete this post")
}
if isOwnerCondition == true && (isEditingEnabledCondition || isAdminCondition == true) {
    print("You can delete this post")
}
if (isOwnerCondition == true && isEditingEnabledCondition) || isAdminCondition == true {
    print("You can delete this post")
}

// Switch statements
enum Weather {
    case sun, rain, wind, snow, unknown
}
let forecast = Weather.sun
if forecast == .sun {
    print("It should be a nice day.")
} else if forecast == .rain {
    print("Pack an umbrella.")
} else if forecast == .wind {
    print("Wear something warm")
} else if forecast == .rain {
    print("School is cancelled.")
} else {
    print("Our forecast generator is broken!")
}

switch forecast {
case .sun:
    print("It should be a nice day.")
case .rain:
    print("Pack an umbrella.")
case .wind:
    print("Wear something warm")
case .snow:
    print("School is cancelled.")
case .unknown:
    print("Our forecast generator is broken!")
}

let place = "Metropolis"
switch place {
case "Gotham":
    print("You're Batman!")
case "Mega-City One":
    print("You're Judge Dredd!")
case "Wakanda":
    print("You're Black Panther!")
default:
    print("Who are you?")
}

var dayVar = 5

print("My true love gave to me…")
switch dayVar {
case 5:
    print("5 golden rings")
case 4:
    print("4 calling birds")
case 3:
    print("3 French hens")
case 2:
    print("2 turtle doves")
default:
    print("A partridge in a pear tree")
}

dayVar = 3
print("My true love gave to me…")
switch dayVar {
case 5:
    print("5 golden rings")
    fallthrough
case 4:
    print("4 calling birds")
    fallthrough
case 3:
    print("3 French hens")
    fallthrough
case 2:
    print("2 turtle doves")
    fallthrough
default:
    print("A partridge in a pear tree")
}

// Ternary operator
let canVote = myAge >= 18 ? "Yes" : "No"
